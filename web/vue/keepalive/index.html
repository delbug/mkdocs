<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>面试官：说说你对keep-alive的理解是什么？ - 前端技术文档</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u9762\u8bd5\u5b98\uff1a\u8bf4\u8bf4\u4f60\u5bf9keep-alive\u7684\u7406\u89e3\u662f\u4ec0\u4e48\uff1f";
        var mkdocs_page_input_path = "web\\vue\\keepalive.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> 前端技术文档
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">首页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">前端基础</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >CSS</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../css/">概述</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >基础概念</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../css/selector/">选择器</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../css/box/">盒子模型</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../css/animation/">动画过渡</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >布局</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../css/grid/">Grid布局</a>
                </li>
                <li class="toctree-l3"><a class="" href="../../css/flex.md">Flex布局</a>
                </li>
                <li class="toctree-l3"><a class="" href="../../css/position.md">定位布局</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >进阶</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../css/css_performance/">CSS性能</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../css/sass_less_stylus/">预处理器</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../css/css3_features/">CSS3新特性</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../css/dp_px_dpr_ppi/">像素单位</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >实践</a>
    <ul>
                <li class="toctree-l3"><a class="" href="../../css/variables.md">变量使用</a>
                </li>
                <li class="toctree-l3"><a class="" href="../../css/media_queries.md">媒体查询</a>
                </li>
                <li class="toctree-l3"><a class="" href="../../css/print_styles.md">打印样式</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >JavaScript</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../JavaScript/">概述</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >基础概念</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/data_type/">数据类型</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/type_conversion/">类型转换</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/typeof_instanceof/">typeof和instanceof</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >作用域与闭包</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/scope/">作用域</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/closure/">闭包</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >对象与原型</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/this/">this指向</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/prototype/">原型和原型链</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/inherit/">继承</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/new/">new操作符</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >执行机制</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/context_stack/">执行上下文和执行栈</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/event_loop/">事件循环</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >DOM与事件</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/Dom/">DOM操作</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/BOM/">BOM操作</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/event_Model/">事件模型</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/event_agent/">事件代理</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >网络通信</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/ajax/">Ajax</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >函数编程</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/functional_programming/">函数式编程</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/function_cache/">函数缓存</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/bind_call_apply/">bind/call/apply</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/debounce_throttle/">防抖和节流</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >数据处理</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/copy/">深浅拷贝</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/array_api/">数组API</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/string_api/">字符串API</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/regexp/">正则表达式</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/js_data_structure/">数据结构</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >性能优化</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/tail_recursion/">尾递归优化</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/memory_leak/">内存泄漏</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >应用实践</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/cache/">前端缓存</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/security/">前端安全</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/single_sign/">单点登录</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/loss_accuracy/">精度丢失</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/visible/">可视区域判断</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/pull_up_loading_pull_down_refresh/">上拉加载下拉刷新</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/continue_to_upload/">断点续传</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../typescript/">TypeScript</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../es6/">ES6+</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">前端框架</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../vue3/">Vue3</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../">Vue2</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../React/">React</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Node.js开发</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../NodeJS/">Node.js</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工程化工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../webpack/">Webpack</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../git/">Git</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络与系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../http/">HTTP</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../linux/">Linux</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">算法与设计</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../algorithm/">算法</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../design/">设计模式</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">小程序开发</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../applet/">小程序</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">前端技术文档</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">面试官：说说你对keep-alive的理解是什么？</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="keep-alive">面试官：说说你对keep-alive的理解是什么？</h1>
<p><img alt="" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9nSDMxdUY5VklpYlRaSXdpY3ZmUkR3STRiamRBVGlhVEpFZDNzamRoeTd3MDlVM0k5ZERjNUVVSUNFVk1WSVE2aDFYMjVpY1NRT3lraWFwWEpEUFM0VGJST0l3LzY0MA?x-oss-process=image/format,png" /></p>
<h2 id="keep-alive_1">一、Keep-alive 是什么</h2>
<p><code>keep-alive</code>是<code>vue</code>中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染<code>DOM</code></p>
<p><code>keep-alive</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p>
<p><code>keep-alive</code>可以设置以下<code>props</code>属性：</p>
<ul>
<li>
<p><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存</p>
</li>
<li>
<p><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存</p>
</li>
<li>
<p><code>max</code> - 数字。最多可以缓存多少组件实例</p>
</li>
</ul>
<p>关于<code>keep-alive</code>的基本用法：</p>
<pre><code class="language-go">&lt;keep-alive&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre>
<p>使用<code>includes</code>和<code>exclude</code>：</p>
<pre><code class="language-go">&lt;keep-alive include=&quot;a,b&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;
&lt;keep-alive :include=&quot;/a|b/&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

&lt;!-- 数组 (使用 `v-bind`) --&gt;
&lt;keep-alive :include=&quot;['a', 'b']&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre>
<p>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)，匿名组件不能被匹配</p>
<p>设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（<code>activated</code>与<code>deactivated</code>）：</p>
<ul>
<li>
<p>首次进入组件时：<code>beforeRouteEnter</code> &gt; <code>beforeCreate</code> &gt; <code>created</code>&gt; <code>mounted</code> &gt; <code>activated</code> &gt; ... ... &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></p>
</li>
<li>
<p>再次进入组件时：<code>beforeRouteEnter</code> &gt;<code>activated</code> &gt; ... ... &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></p>
</li>
</ul>
<h2 id="_1">二、使用场景</h2>
<p>使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用<code>keepalive</code></p>
<p>举个栗子:</p>
<p>当我们从<code>首页</code>–&gt;<code>列表页</code>–&gt;<code>商详页</code>–&gt;<code>再返回</code>，这时候列表页应该是需要<code>keep-alive</code></p>
<p>从<code>首页</code>–&gt;<code>列表页</code>–&gt;<code>商详页</code>–&gt;<code>返回到列表页(需要缓存)</code>–&gt;<code>返回到首页(需要缓存)</code>–&gt;<code>再次进入列表页(不需要缓存)</code>，这时候可以按需来控制页面的<code>keep-alive</code></p>
<p>在路由中设置<code>keepAlive</code>属性判断是否需要缓存</p>
<pre><code class="language-go">{
  path: 'list',
  name: 'itemList', // 列表页
  component (resolve) {
    require(['@/pages/item/list'], resolve)
 },
 meta: {
  keepAlive: true,
  title: '列表页'
 }
}
</code></pre>
<p>使用<code>&lt;keep-alive&gt;</code></p>
<pre><code class="language-go">&lt;div id=&quot;app&quot; class='wrapper'&gt;
    &lt;keep-alive&gt;
        &lt;!-- 需要缓存的视图组件 --&gt; 
        &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;
     &lt;/keep-alive&gt;
      &lt;!-- 不需要缓存的视图组件 --&gt;
     &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;
&lt;/div&gt;
</code></pre>
<h2 id="_2">三、原理分析</h2>
<p><code>keep-alive</code>是<code>vue</code>中内置的一个组件</p>
<p>源码位置：src/core/components/keep-alive.js</p>
<pre><code class="language-go">export default {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },

  created () {
    this.cache = Object.create(null)
    this.keys = []
  },

  destroyed () {
    for (const key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys)
    }
  },

  mounted () {
    this.$watch('include', val =&gt; {
      pruneCache(this, name =&gt; matches(val, name))
    })
    this.$watch('exclude', val =&gt; {
      pruneCache(this, name =&gt; !matches(val, name))
    })
  },

  render() {
    /* 获取默认插槽中的第一个组件节点 */
    const slot = this.$slots.default
    const vnode = getFirstComponentChild(slot)
    /* 获取该组件节点的componentOptions */
    const componentOptions = vnode &amp;&amp; vnode.componentOptions

    if (componentOptions) {
      /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */
      const name = getComponentName(componentOptions)

      const { include, exclude } = this
      /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */
      if (
        (include &amp;&amp; (!name || !matches(include, name))) ||
        // excluded
        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))
      ) {
        return vnode
      }

      const { cache, keys } = this
      /* 获取组件的key值 */
      const key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
        : vnode.key
     /*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance
        // make current key freshest
        remove(keys, key)
        keys.push(key)
      }
        /* 如果没有命中缓存，则将其设置进缓存 */
        else {
        cache[key] = vnode
        keys.push(key)
        // prune oldest entry
        /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */
        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode)
        }
      }

      vnode.data.keepAlive = true
    }
    return vnode || (slot &amp;&amp; slot[0])
  }
}
</code></pre>
<p>可以看到该组件没有<code>template</code>，而是用了<code>render</code>，在组件渲染的时候会自动执行<code>render</code>函数</p>
<p><code>this.cache</code>是一个对象，用来存储需要缓存的组件，它将以如下形式存储：</p>
<pre><code class="language-go">this.cache = {
    'key1':'组件1',
    'key2':'组件2',
    // ...
}
</code></pre>
<p>在组件销毁的时候执行<code>pruneCacheEntry</code>函数</p>
<pre><code class="language-go">function pruneCacheEntry (
  cache: VNodeCache,
  key: string,
  keys: Array&lt;string&gt;,
  current?: VNode
) {
  const cached = cache[key]
  /* 判断当前没有处于被渲染状态的组件，将其销毁*/
  if (cached &amp;&amp; (!current || cached.tag !== current.tag)) {
    cached.componentInstance.$destroy()
  }
  cache[key] = null
  remove(keys, key)
}
</code></pre>
<p>在<code>mounted</code>钩子函数中观测 <code>include</code> 和 <code>exclude</code> 的变化，如下：</p>
<pre><code class="language-go">mounted () {
    this.$watch('include', val =&gt; {
        pruneCache(this, name =&gt; matches(val, name))
    })
    this.$watch('exclude', val =&gt; {
        pruneCache(this, name =&gt; !matches(val, name))
    })
}
</code></pre>
<p>如果<code>include</code> 或<code>exclude</code> 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行<code>pruneCache</code>函数，函数如下：</p>
<pre><code class="language-go">function pruneCache (keepAliveInstance, filter) {
  const { cache, keys, _vnode } = keepAliveInstance
  for (const key in cache) {
    const cachedNode = cache[key]
    if (cachedNode) {
      const name = getComponentName(cachedNode.componentOptions)
      if (name &amp;&amp; !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode)
      }
    }
  }
}
</code></pre>
<p>在该函数内对<code>this.cache</code>对象进行遍历，取出每一项的<code>name</code>值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用<code>pruneCacheEntry</code>函数将其从<code>this.cache</code>对象剔除即可</p>
<p>关于<code>keep-alive</code>的最强大缓存功能是在<code>render</code>函数中实现</p>
<p>首先获取组件的<code>key</code>值：</p>
<pre><code class="language-go">const key = vnode.key == null? 
componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
: vnode.key
</code></pre>
<p>拿到<code>key</code>值后去<code>this.cache</code>对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下：</p>
<pre><code class="language-go">/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */
if (cache[key]) {
    vnode.componentInstance = cache[key].componentInstance
    /* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */
    remove(keys, key)
    keys.push(key)
} 
</code></pre>
<p>直接从缓存中拿 <code>vnode</code> 的组件实例，此时重新调整该组件<code>key</code>的顺序，将其从原来的地方删掉并重新放在<code>this.keys</code>中最后一个</p>
<p><code>this.cache</code>对象中没有该<code>key</code>值的情况，如下：</p>
<pre><code class="language-go">/* 如果没有命中缓存，则将其设置进缓存 */
else {
    cache[key] = vnode
    keys.push(key)
    /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */
    if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {
        pruneCacheEntry(cache, keys[0], keys, this._vnode)
    }
}
</code></pre>
<p>表明该组件还没有被缓存过，则以该组件的<code>key</code>为键，组件<code>vnode</code>为值，将其存入<code>this.cache</code>中，并且把<code>key</code>存入<code>this.keys</code>中</p>
<p>此时再判断<code>this.keys</code>中缓存组件的数量是否超过了设置的最大缓存数量值<code>this.max</code>，如果超过了，则把第一个缓存组件删掉</p>
<h2 id="_3">四、思考题：缓存后如何获取数据</h2>
<p>解决方案可以有以下两种：</p>
<ul>
<li>
<p>beforeRouteEnter</p>
</li>
<li>
<p>actived</p>
</li>
</ul>
<h3 id="beforerouteenter">beforeRouteEnter</h3>
<p>每次组件渲染的时候，都会执行<code>beforeRouteEnter</code></p>
<pre><code class="language-go">beforeRouteEnter(to, from, next){
    next(vm=&gt;{
        console.log(vm)
        // 每次进入路由执行
        vm.getData()  // 获取数据
    })
},
</code></pre>
<h3 id="actived">actived</h3>
<p>在<code>keep-alive</code>缓存的组件被激活的时候，都会执行<code>actived</code>钩子</p>
<pre><code class="language-go">activated(){
   this.getData() // 获取数据
},
</code></pre>
<p>注意：服务器端渲染期间<code>avtived</code>不被调用</p>
<h2 id="_4">参考文献</h2>
<ul>
<li>https://www.cnblogs.com/dhui/p/13589401.html</li>
<li>https://www.cnblogs.com/wangjiachen666/p/11497200.html</li>
<li>https://vue3js.cn/docs/zh  </li>
</ul>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../..";</script>
    <script src="../../../js/theme_extra.js"></script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
