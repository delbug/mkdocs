<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>面试官：Vue实例挂载的过程 - 前端技术文档</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u9762\u8bd5\u5b98\uff1aVue\u5b9e\u4f8b\u6302\u8f7d\u7684\u8fc7\u7a0b";
        var mkdocs_page_input_path = "web\\vue\\new_vue.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> 前端技术文档
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">首页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">前端基础</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >CSS</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../css/">概述</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >基础概念</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../css/selector/">选择器</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../css/box/">盒子模型</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../css/animation/">动画过渡</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >布局</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../css/grid/">Grid布局</a>
                </li>
                <li class="toctree-l3"><a class="" href="../../css/flex.md">Flex布局</a>
                </li>
                <li class="toctree-l3"><a class="" href="../../css/position.md">定位布局</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >进阶</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../css/css_performance/">CSS性能</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../css/sass_less_stylus/">预处理器</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../css/css3_features/">CSS3新特性</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../css/dp_px_dpr_ppi/">像素单位</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >实践</a>
    <ul>
                <li class="toctree-l3"><a class="" href="../../css/variables.md">变量使用</a>
                </li>
                <li class="toctree-l3"><a class="" href="../../css/media_queries.md">媒体查询</a>
                </li>
                <li class="toctree-l3"><a class="" href="../../css/print_styles.md">打印样式</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >JavaScript</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../JavaScript/">概述</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >基础概念</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/data_type/">数据类型</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/type_conversion/">类型转换</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/typeof_instanceof/">typeof和instanceof</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >作用域与闭包</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/scope/">作用域</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/closure/">闭包</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >对象与原型</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/this/">this指向</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/prototype/">原型和原型链</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/inherit/">继承</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/new/">new操作符</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >执行机制</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/context_stack/">执行上下文和执行栈</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/event_loop/">事件循环</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >DOM与事件</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/Dom/">DOM操作</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/BOM/">BOM操作</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/event_Model/">事件模型</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/event_agent/">事件代理</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >网络通信</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/ajax/">Ajax</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >函数编程</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/functional_programming/">函数式编程</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/function_cache/">函数缓存</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/bind_call_apply/">bind/call/apply</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/debounce_throttle/">防抖和节流</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >数据处理</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/copy/">深浅拷贝</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/array_api/">数组API</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/string_api/">字符串API</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/regexp/">正则表达式</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/js_data_structure/">数据结构</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >性能优化</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/tail_recursion/">尾递归优化</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/memory_leak/">内存泄漏</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >应用实践</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/cache/">前端缓存</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/security/">前端安全</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/single_sign/">单点登录</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/loss_accuracy/">精度丢失</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/visible/">可视区域判断</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/pull_up_loading_pull_down_refresh/">上拉加载下拉刷新</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../JavaScript/continue_to_upload/">断点续传</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../typescript/">TypeScript</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../es6/">ES6+</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">前端框架</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../vue3/">Vue3</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../">Vue2</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../React/">React</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Node.js开发</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../NodeJS/">Node.js</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">工程化工具</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../webpack/">Webpack</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../git/">Git</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">网络与系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../http/">HTTP</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../linux/">Linux</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">算法与设计</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../algorithm/">算法</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../design/">设计模式</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">小程序开发</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../applet/">小程序</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">前端技术文档</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">面试官：Vue实例挂载的过程</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="vue">面试官：Vue实例挂载的过程</h1>
<p><img alt="" src="https://static.vue-js.com/63194810-3a09-11eb-85f6-6fac77c0c9b3.png" /></p>
<h2 id="_1">一、思考</h2>
<p>我们都听过知其然知其所以然这句话</p>
<p>那么不知道大家是否思考过<code>new Vue()</code>这个过程中究竟做了些什么？</p>
<p>过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等</p>
<h2 id="_2">一、分析</h2>
<p>首先找到<code>vue</code>的构造函数</p>
<p>源码位置：src\core\instance\index.js</p>
<pre><code class="language-js">function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
</code></pre>
<p><code>options</code>是用户传递过来的配置项，如<code>data、methods</code>等常用的方法</p>
<p><code>vue</code>构建函数调用<code>_init</code>方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法</p>
<pre><code class="language-js">initMixin(Vue);     // 定义 _init
stateMixin(Vue);    // 定义 $set $get $delete $watch 等
eventsMixin(Vue);   // 定义事件  $on  $once $off $emit
lifecycleMixin(Vue);// 定义 _update  $forceUpdate  $destroy
renderMixin(Vue);   // 定义 _render 返回虚拟dom
</code></pre>
<p>首先可以看<code>initMixin</code>方法，发现该方法在<code>Vue</code>原型上定义了<code>_init</code>方法</p>
<p>源码位置：src\core\instance\init.js</p>
<pre><code class="language-js">Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++
    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    vm._isVue = true
    // merge options
    // 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法
    if (options &amp;&amp; options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else { // 合并vue属性
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      // 初始化proxy拦截器
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    // 初始化组件生命周期标志位
    initLifecycle(vm)
    // 初始化组件事件侦听
    initEvents(vm)
    // 初始化渲染方法
    initRender(vm)
    callHook(vm, 'beforeCreate')
    // 初始化依赖注入内容，在初始化data、props之前
    initInjections(vm) // resolve injections before data/props
    // 初始化props/data/method/watch/methods
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }
    // 挂载元素
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
</code></pre>
<p>仔细阅读上面的代码，我们得到以下结论：</p>
<ul>
<li>
<p>在调用<code>beforeCreate</code>之前，数据初始化并未完成，像<code>data</code>、<code>props</code>这些属性无法访问到</p>
</li>
<li>
<p>到了<code>created</code>的时候，数据已经初始化完成，能够访问<code>data</code>、<code>props</code>这些属性，但这时候并未完成<code>dom</code>的挂载，因此无法访问到<code>dom</code>元素</p>
</li>
<li>挂载方法是调用<code>vm.$mount</code>方法</li>
</ul>
<p><code>initState</code>方法是完成<code>props/data/method/watch/methods</code>的初始化</p>
<p>源码位置：src\core\instance\state.js</p>
<pre><code class="language-js">export function initState (vm: Component) {
  // 初始化组件的watcher列表
  vm._watchers = []
  const opts = vm.$options
  // 初始化props
  if (opts.props) initProps(vm, opts.props)
  // 初始化methods方法
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    // 初始化data  
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
</code></pre>
<p>我们和这里主要看初始化<code>data</code>的方法为<code>initData</code>，它与<code>initState</code>在同一文件上</p>
<pre><code class="language-js">function initData (vm: Component) {
  let data = vm.$options.data
  // 获取到组件上的data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      // 属性名不能与方法名重复
      if (methods &amp;&amp; hasOwn(methods, key)) {
        warn(
          `Method &quot;${key}&quot; has already been defined as a data property.`,
          vm
        )
      }
    }
    // 属性名不能与state名称重复
    if (props &amp;&amp; hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' &amp;&amp; warn(
        `The data property &quot;${key}&quot; is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) { // 验证key值的合法性
      // 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  // 响应式监听data是数据的变化
  observe(data, true /* asRootData */)
}
</code></pre>
<p>仔细阅读上面的代码，我们可以得到以下结论：</p>
<ul>
<li>
<p>初始化顺序：<code>props</code>、<code>methods</code>、<code>data</code></p>
</li>
<li>
<p><code>data</code>定义的时候可选择函数形式或者对象形式（组件只能为函数形式）</p>
</li>
</ul>
<p>关于数据响应式在这就不展开详细说明</p>
<p>上文提到挂载方法是调用<code>vm.$mount</code>方法</p>
<p>源码位置：</p>
<pre><code class="language-js">Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 获取或查询元素
  el = el &amp;&amp; query(el)

  /* istanbul ignore if */
  // vue 不允许直接挂载到body或页面文档上
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    // 存在template模板，解析vue模板文件
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      // 通过选择器获取元素内容
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
        mark('compile')
      }
      /**
       *  1.将temmplate解析ast tree
       *  2.将ast tree转换成render语法字符串
       *  3.生成render方法
       */
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
</code></pre>
<p>阅读上面代码，我们能得到以下结论：</p>
<ul>
<li>
<p>不要将根元素放到<code>body</code>或者<code>html</code>上</p>
</li>
<li>
<p>可以在对象中定义<code>template/render</code>或者直接使用<code>template</code>、<code>el</code>表示元素选择器</p>
</li>
<li>
<p>最终都会解析成<code>render</code>函数，调用<code>compileToFunctions</code>，会将<code>template</code>解析成<code>render</code>函数</p>
</li>
</ul>
<p>对<code>template</code>的解析步骤大致分为以下几步：</p>
<ul>
<li>
<p>将<code>html</code>文档片段解析成<code>ast</code>描述符</p>
</li>
<li>
<p>将<code>ast</code>描述符解析成字符串</p>
</li>
<li>
<p>生成<code>render</code>函数</p>
</li>
</ul>
<p>生成<code>render</code>函数，挂载到<code>vm</code>上后，会再次调用<code>mount</code>方法</p>
<p>源码位置：src\platforms\web\runtime\index.js</p>
<pre><code class="language-js">// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; inBrowser ? query(el) : undefined
  // 渲染组件
  return mountComponent(this, el, hydrating)
}
</code></pre>
<p>调用<code>mountComponent</code>渲染组件</p>
<pre><code class="language-js">export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  // 如果没有获取解析的render函数，则会抛出警告
  // render是解析模板文件生成的
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        // 没有获取到vue的模板文件
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  // 执行beforeMount钩子
  callHook(vm, 'beforeMount')

  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
    updateComponent = () =&gt; {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    // 定义更新函数
    updateComponent = () =&gt; {
      // 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render
      vm._update(vm._render(), hydrating)
    }
  }
  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  // 监听当前组件状态，当有数据变化时，更新组件
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted &amp;&amp; !vm._isDestroyed) {
        // 数据更新引发的组件更新
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
</code></pre>
<p>阅读上面代码，我们得到以下结论：</p>
<ul>
<li>会触发<code>beforeCreate</code>钩子</li>
<li>定义<code>updateComponent</code>渲染页面视图的方法</li>
<li>监听组件数据，一旦发生变化，触发<code>beforeUpdate</code>生命钩子</li>
</ul>
<p><code>updateComponent</code>方法主要执行在<code>vue</code>初始化时声明的<code>render</code>，<code>update</code>方法</p>
<p><code>render</code>的作用主要是生成<code>vnode</code></p>
<p>源码位置：src\core\instance\render.js</p>
<pre><code class="language-js">// 定义vue 原型上的render方法
Vue.prototype._render = function (): VNode {
    const vm: Component = this
    // render函数来自于组件的option
    const { render, _parentVnode } = vm.$options

    if (_parentVnode) {
        vm.$scopedSlots = normalizeScopedSlots(
            _parentVnode.data.scopedSlots,
            vm.$slots,
            vm.$scopedSlots
        )
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode
    // render self
    let vnode
    try {
        // There's no need to maintain a stack because all render fns are called
        // separately from one another. Nested component's render fns are called
        // when parent component is patched.
        currentRenderingInstance = vm
        // 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode
        vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e) {
        handleError(e, vm, `render`)
        // return error render result,
        // or previous vnode to prevent render error causing blank component
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== 'production' &amp;&amp; vm.$options.renderError) {
            try {
                vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
            } catch (e) {
                handleError(e, vm, `renderError`)
                vnode = vm._vnode
            }
        } else {
            vnode = vm._vnode
        }
    } finally {
        currentRenderingInstance = null
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) {
        vnode = vnode[0]
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
        if (process.env.NODE_ENV !== 'production' &amp;&amp; Array.isArray(vnode)) {
            warn(
                'Multiple root nodes returned from render function. Render function ' +
                'should return a single root node.',
                vm
            )
        }
        vnode = createEmptyVNode()
    }
    // set parent
    vnode.parent = _parentVnode
    return vnode
}
</code></pre>
<p><code>_update</code>主要功能是调用<code>patch</code>，将<code>vnode</code>转换为真实<code>DOM</code>，并且更新到页面中</p>
<p>源码位置：src\core\instance\lifecycle.js</p>
<pre><code class="language-js">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    // 设置当前激活的作用域
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      // 执行具体的挂载逻辑
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  }
</code></pre>
<h2 id="_3">三、结论</h2>
<ul>
<li><code>new Vue</code>的时候调用会调用<code>_init</code>方法</li>
<li>定义 <code>$set</code>、<code>$get</code> 、<code>$delete</code>、<code>$watch</code> 等方法</li>
<li>定义 <code>$on</code>、<code>$off</code>、<code>$emit</code>、<code>$off</code>等事件</li>
<li>
<p>定义 <code>_update</code>、<code>$forceUpdate</code>、<code>$destroy</code>生命周期</p>
</li>
<li>
<p>调用<code>$mount</code>进行页面的挂载</p>
</li>
<li>挂载的时候主要是通过<code>mountComponent</code>方法</li>
<li>定义<code>updateComponent</code>更新函数</li>
<li>执行<code>render</code>生成虚拟<code>DOM</code></li>
<li><code>_update</code>将虚拟<code>DOM</code>生成真实<code>DOM</code>结构，并且渲染到页面中</li>
</ul>
<h2 id="_4">参考文献</h2>
<ul>
<li>https://www.cnblogs.com/gerry2019/p/12001661.html</li>
<li>https://github.com/vuejs/vue/tree/dev/src/core/instance </li>
<li>https://vue3js.cn</li>
</ul>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../..";</script>
    <script src="../../../js/theme_extra.js"></script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
